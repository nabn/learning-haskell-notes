* Type Matching

Match the following functions to their type signatures

Functions:
#+BEGIN_SRC haskell
not    -- 1
length -- 2
concat -- 3
head   -- 4
(<)    -- 5
#+END_SRC
Type Signatures:

#+BEGIN_SRC haskell
_ :: [a] -> a                -- a
_ :: [[a]] -> [a]            -- b
_ :: Bool -> Bool            -- c
_ :: [a] -> Int              -- d
_ :: Ord a => a -> a -> Bool -- e
#+END_SRC

Answer:

1 - c
2 - d
3 - b
4 - a
5 - e

* Type Arguments

(pg 161)

Given a function and its type, tell us what type results from applying
some or all of the arguments.

_note_: I'm only going to give the answers here, since writing this
all out would be a huge pain.

Answers:
1. (a)
2. (d)
3. (d)
4. (c)
5. (a)
6. (c)
7. (d)
8. (a)
9. (c)
* Parametricity
1. Given the type a -> a, which is the type for id, attempt to make a
function that is not bottom and terminates successfully that does
something other than returning the same value. This is impossible, but
you should try anyway.

  Answer:
  I couldn't do it. Except with bottom. Got some cool error messages though.

2. We can get a more comfortable appreciation of parametricity by
   looking at a -> a -> a. This hypothetical function a -> a -> a has
   two -- and only two -- implementations. Write both possible
   versions of a -> a -> a. After doing so, try to violate the
   constraints of parametrically polymorhpic values we outlined above

Answer:

#+BEGIN_SRC haskell
f1 :: a -> a -> a
f1 x y = x

f2 :: a -> a -> a
f2 x y = y
#+END_SRC

3. Implement a -> b -> b. How many implementations can it have? Does
   the behavior change when the types of a and b change?

Answer:

#+BEGIN_SRC haskell
f3 :: a -> b -> b
f3 x y = y
#+END_SRC

It can only have one implementation. The behavior does not change no
matter what types a and b end up being concretely.

* Apply yourself

Look at the following pairs of functions. One is a general type
definition and one is partially applied. Note how the type changes
between them.

1.
#+BEGIN_SRC haskell
(++) :: [a] -> [a] -> [a]
myConcat x = x ++ "yo"
#+END_SRC

Answer:
#+BEGIN_SRC haskell
myConcat :: [Char] -> [Char]
#+END_SRC

2.
#+BEGIN_SRC haskell
(*) :: Num a => a -> a -> a
myMult x = (x / 3) * 5
#+END_SRC

Answer:
#+BEGIN_SRC haskell
myMult :: Fractional a => a -> a
#+END_SRC

3.
#+BEGIN_SRC haskell
take:: Int -> [a] -> [a]
myTake x = take x "hey you"
#+END_SRC

Answer:
#+BEGIN_SRC haskell
myTake :: Int -> [Char]
#+END_SRC

4.
#+BEGIN_SRC haskell
(>) :: Ord a => a -> a -> Bool
myCom x = x > (length [1..10])
#+END_SRC

Answer:
#+BEGIN_SRC haskell
myCom :: Int -> Bool
#+END_SRC

5.
#+BEGIN_SRC haskell
(<) :: Ord a => a -> a -> Bool
myAlph x = x < 'z'
#+END_SRC

Answer:
#+BEGIN_SRC haskell
myAlph :: Char -> Bool
#+END_SRC
