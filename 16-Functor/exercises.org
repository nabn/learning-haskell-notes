* Be Kind

Given a type signature, determine the kinds of each type variable:

#+BEGIN_SRC haskell
-- 1: what is the kind of a
g :: a -> a

-- 2 What are the kinds of b and T?
f :: a -> b a -> T (b a)

-- 3 What's the kind of c?
h :: c a b -> c b a
#+END_SRC

Answers:

1. ~*~
2. ~* -> *~ and ~* -> *~
3. ~* -> * -> *~
* Heavy Lifting

Add ~fmap~ parentheses, and function composition to the expression as
needed for the expression to typecheck and produce the expected
result.

#+BEGIN_SRC haskell
-- 1, expected result: a == [2]
a = fmap (+1) $ read "[1]" :: [Int]

-- 2, expected result: b == Just ["Hi,lol", "Hellolol"]
b = (fmap . fmap) (++ "lol") (Just ["Hi,", "Hello"])

-- 3, expected result: c 1 == -2
c = fmap (*2) (\x -> x - 2)

-- 4, expected result: d 0 == "1[0,1,2,3]"
d = fmap ((return '1' ++) . show) (\x -> [x, 1..3])

-- 5, expected result: e == 3693
e :: IO Integer
e = let ioi = readIO "1" :: IO Integer
        changed = (read ("123"++) . show ioi)
    in (*3) changed
#+END_SRC

* Instances of Func

Implement ~Functor~ instances for the following datatypes. Use the
QuickCheck properties we just showed you to validate them.


Answers:

See instancesOfFunc.hs

* Possibility

Write a Functor instance for a dataype identital to ~Maybe~.

#+BEGIN_SRC haskell
data Possibly a =
    LolNope
  | Yeppers a
  deriving (Eq, Show)

instance Functor Possibly where
  fmap _ LolNope = LolNope
  fmap f (Yeppers x) = Yeppers $ f x
#+END_SRC

* Short Exercise

1. Write a ~Functor~ instace for a datatype identical to ~Either~.

#+BEGIN_SRC haskell
data Sum a b = First a | Second b deriving (Eq, Show)

instance Functor (Sum a) where
  fmap _ (First x) = First x
  fmap f (Second y) = Second $ f y
#+END_SRC

2. Why is a ~Functor~ instance that applies the function only to
   ~First~, Either's Left, impossible?

An instance of ~Functor~ must have kind ~* -> *~. Since ~Sum~ has kind
~* -> * -> *~, we must partially apply ~Sum~ to a type variable to get
a type of kind ~* -> *~. This partial application will always be over
~First~ or ~Left~, fixing them as part of the structure of the type.
