* Chapter 1: Anything From Almost Nothing
** 1.6 Multiple Arugments

There's an expression in here:

(λx(λy.xy))(λz.a) 1

Which I would expect to look like:

(λx.(λy.xy))(λz.a) 1

Especially given that in earlier parts of this section, there is a dot
in that location.

Why was the dot omitted?
* Chapter 2: Basic Expressions and Functions
- The syntax for indentation was introduced, but not for
  semicolons. What's the deal with them?

** Exercises with Let and where
I'm confused about what they're asking from us. Where clauses are not
expressions, so we can't translate these directly without doing some
sort of binding.

What did other people come up with?

* Chapter 3: String
** Types of concatenation functions
Prelude> :type (++)
(++) :: [a] -> [a] -> [a]
Prelude> :type concat
concat :: Foldable t => t [a] -> [a]

But the book says:
#+BEGIN_SRC haskell
concat :: [[a]] -> [a]
#+END_SRC

I guess the book does explain this.

** Concatenation and scoping
- Can we talk about "right associativity"?

** Building functions
- Lets talk about exercise 5. I want to see others implementations (pg 115)

* Chapter 4: Basic Types

Let's talk about indentation
* Chapter 5: Types
- "Thinking about types as being like sets will help guide your
  intuition on what types are and how they work in a mathematical
  sense" pg 145.
  - How?
- pg 149 talks about the info of (->) can we break this down?
  - It's a "type constructor for functions"
  - _I think_:
    - It's infix, with low precedence
    - and right associative
- pg 161 "Currying and uncurring functions of three or more arugments
  automatically is quite possible but trickier"
  - Want to try?
- pg 161 - 164 -- Maybe go through these quickly?
- pg 166 "A subclass cannot override the methods of its superclass"
  - Really? Why?
- pg 167 These are pretty cool questions
- pg 175, question 3, What is the answer? I said (b)
- pg 179, question 6, Let's do this
- pg 183 Principle types. Lets talk about what they are
- What is the type of the empty list?
  - Like, is it [a]?
- pg 185. Let's talk about the difference between parametric and
  ad-hoc polymorphism. Especially in regards to these definitions.
* Chapter 6: Typeclasses
** Pages/questions from version 0.11.2

- pg 188: Lets talk about the expression problem
- pg 188: What does it mean for typclasses to "dispatch on type"
- General: Talk about "Implements" vs "Has instances for"
- pg 194: "Since Real cannot override the methods of Num, this
  typeclass inheritance is _only_ additive and the ambiguity problems
  caused by multiple inheritance in some programming languages is
  avoided."
- pg 196: Why don't we need to constrain by Fractional _and_ Num?
- General: What do the lines in ~:info Typeclass~ that look like:

      {-# MINIMAL compare | (<=) #-}

  mean?
- pg 207: Talk about IO (), specifically, why main has to be IO ().
  - Also "An IO action that returns ()"
- pg 210: ""

** Pages/questions from version 0.12.0
- pg 179: Can we walk through a couple of these?
  - Specifically 2, 5, 6
  - Very specifically: 5. I don't think I got this one right.

- pg 200: Can we unpack the language in the first few paragraphs of
  6.12? Namely "instances"

- I want to talk about dispatching on type as well.

- pg 208
  - Exercise 1, can we make it typecheck?
  - Exercise 3.b. Can we walk through this error?

- General: What's with data definitions like:
  ~data MyThing = Thing Integer~? Will we cover these later?

- 209: Exercise 4. This totally typechecks. Talk about Data
  constructor partial application?

- pg 210: Exercise 1. Why???? I would think you could be more general...
  - This seems like a trick based on something we haven't learned yet,
    and less about typeclasses.
* Chapter 7: More Functional Patterns
- pg 223: In
    : (\x -> x * 3) :: Integer -> Integer
  Are the two uses of (->) the same, on the left and right side of ::?

- pg 224: Exercise 1. They produce the same effect, but the method of
  curring is different, right? Actually, I just tested this in the repl:

  #+BEGIN_SRC haskell
  -- using (++) makes it clearer
  (\x -> \y -> \z -> x ++ y ++ z)
  mTh x y z = x ++ y ++ z
  #+END_SRC

  I guess it just binds the leftmost arguments first. Which I guess
  makes sense.

- pg 225: Any and all data constructors!!!

- pg 239: talk about explicit parenthetization of type signatures

- pg 251: Question 5. I don't understand

- General: Is there such thing as exponent types??

- pg 261: Question 1.a) Does divMod make this simpler? I don't think I
  got the right answer.

- pg 263: Question 6: lets talk about this
* Chapter 8: Recursion

- pg 277: Recursion is self-referntial composition. What does that mean?

- pg: 280: "Bottom is used in haskell to refer to computations that do
  not successfully return a value." So bottom is not itself a value?
  What does it mean to refer to a "computation" in this sense?

- pg 292: Recursion question 2. We talk about partial functions being
  bad, but we're writing them for exercises like this. Is that
  something we should be concerned about?
  - Or at least, it is "bottom" when given a negative argument, or
    floating point argument.
* Chapter 9: Lists
- pg 302: What is a spine? What is a cons cell?
- pg 315: No really, what is a "spine"?
- pg 317: "The length function is only strict in the spine"
  - What does this mean?
- pg 317: "Values in Haskell get reduced to weak head normal form by
  default"
  - What?
- pg 319: If a range isn't evaulated, what is it? How does it know
  where to stop?
- pg 341: Is there any difference between the builtin list and the
  custom definition other than syntax?
